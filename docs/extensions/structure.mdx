---
sidebar_label: Structure
id: extensions-structure
title: Extension Structure
description: The structure of an extension
slug: /extensions/structure
---

Very simply, extensions are gRPC servers that have 4 rpc methods (not to be confused with the arbitrary methods that the extension provides):

- `Name` - Returns the name of the extension.  This name is used when importing the extension into a Kuneiform schema.
- `ListMethods` - Returns a list of usable extensions methods that the extension implements.
- `Execute` - Executes a method on the extension.  This is called from within a Kuneiform action.
- `Initialize` - Initializes a new instance of the extension.  This occurs once each time a Kuneiform schema using the extension is deployed (or when the Kwil daemon is rebooted).

The gRPC interface for Kwil extensions can be found [here](<https://github.com/kwilteam/kwil-extensions/blob/main/proto/extension.proto>).

## When extensions can be used

Custom extensions can be used when deploying your own dedicated Kwil network / daemon.  This can be conceptually thought of as a very particular type of app-chain,
except the app-chain logic (within the extension) should be stateless, and all state is handled by the SQL database.

While extensions can be run as distributed infrastructure, **it is recommended to run them as containerized sidecars**. Running them as sidecars helps prevent
transient errors that can occur when running them as distributed infrastructure.  Containerization forces them to run with sandboxed resources, preventing
them from crashing the daemon (which can cause database corruption).

## Initialization

When a new Kuneiform schema is deployed, it calls the provided `Initialize` method on each extension it imports, for each time it is imported.
If the same extensions is imported twice, it will be initialized twice.  This is done to allow for multiple instances of the same extension to be used
in a single schema.

The `Initialize` method takes a map of initialization variables, and can validate, modify, or add to them.  For example, a hypothetical ERC20 extension
may be imported in Kuneiform as:

```typescript
use erc20 {
    contract_address: "0x1234..."
} as my_token;
```

In this scenario, the `Initialize` method would receive a map containing:
    
```json
{
    "contract_address": "0x1234..."
}
```

The initialize method could then perform validation to ensure that smart contract exists, and potentially add additional variables to the map, such as
the token name, symbol, and decimals.

The returned map is then included in every subsequent request made by the Kuneiform schema to the extension.

## Executing Methods

When an action using an extension is executed, the `Execute` method is called on the extension.  The `Execute` method takes the map of variables returned from the `Initialize` function, an array of scalar values (either strings or integers), and returns an array of scalar values.
**Methods should be case insensitive**.

Following the above example, a hypothetical ERC20 extension may have a `balanceOf` method that takes a single variable, `address`, and returns the balance of
the given address.  This method could be called from within a Kuneiform action as:

```typescript
action use_my_token($wallet_address) public {
    $balance = my_token.balanceOf($wallet_address)
    ...
}
```
